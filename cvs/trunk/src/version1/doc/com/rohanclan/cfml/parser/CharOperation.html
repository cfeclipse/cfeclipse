<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2_04) on Thu Mar 03 18:43:20 PST 2005 -->
<TITLE>
CharOperation
</TITLE>

<META NAME="keywords" CONTENT="com.rohanclan.cfml.parser.CharOperation class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="CharOperation";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/CharOperation.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../com/rohanclan/cfml/parser/CFProblem.html" title="class in com.rohanclan.cfml.parser"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../com/rohanclan/cfml/parser/CommentParser.html" title="class in com.rohanclan.cfml.parser"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="CharOperation.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
com.rohanclan.cfml.parser</FONT>
<BR>
Class CharOperation</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../resources/inherit.gif" ALT="extended by"><B>com.rohanclan.cfml.parser.CharOperation</B>
</PRE>
<HR>
<DL>
<DT>public final class <B>CharOperation</B><DT>extends java.lang.Object</DL>

<P>
This class is a collection of helper methods to manipulate char arrays.
<P>

<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>2.1</DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#NO_CHAR">NO_CHAR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for an empty char array</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#NO_CHAR_CHAR">NO_CHAR_CHAR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for an empty char array with two dimensions.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#CharOperation()">CharOperation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#append(char[], char)">append</A></B>(char[]&nbsp;array,
       char&nbsp;suffix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers a new array with appending the suffix character at the end of the array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#append(char[], int, char[], int, int)">append</A></B>(char[]&nbsp;target,
       int&nbsp;index,
       char[]&nbsp;array,
       int&nbsp;start,
       int&nbsp;end)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Append the given subarray to append to the target array starting at the given index in the target array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#arrayConcat(char[][], char[])">arrayConcat</A></B>(char[][]&nbsp;first,
            char[]&nbsp;second)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers a new array adding the second array at the end of first array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#arrayConcat(char[][], char[][])">arrayConcat</A></B>(char[][]&nbsp;first,
            char[][]&nbsp;second)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers the concatenation of the two arrays.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#concat(char[], char[])">concat</A></B>(char[]&nbsp;first,
       char[]&nbsp;second)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers the concatenation of the two arrays.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#concat(char[], char[], char)">concat</A></B>(char[]&nbsp;first,
       char[]&nbsp;second,
       char&nbsp;separator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers the concatenation of the two arrays inserting the separator character between the two arrays.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#concat(char[], char[], char[])">concat</A></B>(char[]&nbsp;first,
       char[]&nbsp;second,
       char[]&nbsp;third)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers the concatenation of the three arrays.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#concat(char[], char, char[], char, char[])">concat</A></B>(char[]&nbsp;first,
       char&nbsp;sep1,
       char[]&nbsp;second,
       char&nbsp;sep2,
       char[]&nbsp;third)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers the concatenation of the three arrays inserting the sep1 character between the 
 two arrays and sep2 between the last two.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#concat(char, char[], char)">concat</A></B>(char&nbsp;prefix,
       char[]&nbsp;array,
       char&nbsp;suffix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers a new array with prepending the prefix character and appending the suffix 
 character at the end of the array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#concatWith(char[][], char)">concatWith</A></B>(char[][]&nbsp;array,
           char&nbsp;separator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers the concatenation of the given array parts using the given separator between each part.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#concatWith(char[][], char[], char)">concatWith</A></B>(char[][]&nbsp;array,
           char[]&nbsp;name,
           char&nbsp;separator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers the concatenation of the given array parts using the given separator between each
 part and appending the given name at the end.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#concatWith(char[], char[][], char)">concatWith</A></B>(char[]&nbsp;name,
           char[][]&nbsp;array,
           char&nbsp;separator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers the concatenation of the given array parts using the given separator between each
 part and appending the given name at the end.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#contains(char, char[])">contains</A></B>(char&nbsp;character,
         char[]&nbsp;array)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers true if the array contains an occurrence of character, false otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#contains(char, char[][])">contains</A></B>(char&nbsp;character,
         char[][]&nbsp;array)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers true if the array contains an occurrence of character, false otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#deepCopy(char[][])">deepCopy</A></B>(char[][]&nbsp;toCopy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers a deep copy of the toCopy array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#endsWith(char[], char[])">endsWith</A></B>(char[]&nbsp;array,
         char[]&nbsp;toBeFound)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return true if array ends with the sequence of characters contained in toBeFound, 
 otherwise false.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#equals(char[][], char[][])">equals</A></B>(char[][]&nbsp;first,
       char[][]&nbsp;second)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers true if the two arrays are identical character by character, otherwise false.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#equals(char[][], char[][], boolean)">equals</A></B>(char[][]&nbsp;first,
       char[][]&nbsp;second,
       boolean&nbsp;isCaseSensitive)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If isCaseSensite is true, answers true if the two arrays are identical character
 by character, otherwise false.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#equals(char[], char[])">equals</A></B>(char[]&nbsp;first,
       char[]&nbsp;second)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers true if the two arrays are identical character by character, otherwise false.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#equals(char[], char[], boolean)">equals</A></B>(char[]&nbsp;first,
       char[]&nbsp;second,
       boolean&nbsp;isCaseSensitive)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If isCaseSensite is true, answers true if the two arrays are identical character
 by character, otherwise false.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#fragmentEquals(char[], char[], int, boolean)">fragmentEquals</A></B>(char[]&nbsp;fragment,
               char[]&nbsp;name,
               int&nbsp;startIndex,
               boolean&nbsp;isCaseSensitive)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If isCaseSensite is true, the equality is case sensitive, otherwise it is case insensitive.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#hashCode(char[])">hashCode</A></B>(char[]&nbsp;array)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers a hashcode for the array</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#indexOf(char, char[])">indexOf</A></B>(char&nbsp;toBeFound,
        char[]&nbsp;array)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers the first index in the array for which the corresponding character is
 equal to toBeFound.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#indexOf(char, char[], int)">indexOf</A></B>(char&nbsp;toBeFound,
        char[]&nbsp;array,
        int&nbsp;start)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers the first index in the array for which the corresponding character is
 equal to toBeFound starting the search at index start.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#isWhitespace(char)">isWhitespace</A></B>(char&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers true if c is a whitespace according to the JLS (&#92;u000a, &#92;u000c, &#92;u000d, &#92;u0009), otherwise false.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#lastIndexOf(char, char[])">lastIndexOf</A></B>(char&nbsp;toBeFound,
            char[]&nbsp;array)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers the last index in the array for which the corresponding character is
 equal to toBeFound starting from the end of the array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#lastIndexOf(char, char[], int)">lastIndexOf</A></B>(char&nbsp;toBeFound,
            char[]&nbsp;array,
            int&nbsp;startIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers the last index in the array for which the corresponding character is
 equal to toBeFound stopping at the index startIndex.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#lastIndexOf(char, char[], int, int)">lastIndexOf</A></B>(char&nbsp;toBeFound,
            char[]&nbsp;array,
            int&nbsp;startIndex,
            int&nbsp;endIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers the last index in the array for which the corresponding character is
 equal to toBeFound starting from endIndex to startIndex.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#lastSegment(char[], char)">lastSegment</A></B>(char[]&nbsp;array,
            char&nbsp;separator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers the last portion of a name given a separator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#match(char[], char[], boolean)">match</A></B>(char[]&nbsp;pattern,
      char[]&nbsp;name,
      boolean&nbsp;isCaseSensitive)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers true if the pattern matches the given name, false otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#match(char[], int, int, char[], int, int, boolean)">match</A></B>(char[]&nbsp;pattern,
      int&nbsp;patternStart,
      int&nbsp;patternEnd,
      char[]&nbsp;name,
      int&nbsp;nameStart,
      int&nbsp;nameEnd,
      boolean&nbsp;isCaseSensitive)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers true if the a sub-pattern matches the subpart of the given name, false otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#occurencesOf(char, char[])">occurencesOf</A></B>(char&nbsp;toBeFound,
             char[]&nbsp;array)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers the number of occurrences of the given character in the given array, 0 if any.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#occurencesOf(char, char[], int)">occurencesOf</A></B>(char&nbsp;toBeFound,
             char[]&nbsp;array,
             int&nbsp;start)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers the number of occurrences of the given character in the given array starting
 at the given index, 0 if any.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#pathMatch(char[], char[], boolean, char)">pathMatch</A></B>(char[]&nbsp;pattern,
          char[]&nbsp;filepath,
          boolean&nbsp;isCaseSensitive,
          char&nbsp;pathSeparator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers true if the pattern matches the filepath using the pathSepatator, false otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#prefixEquals(char[], char[])">prefixEquals</A></B>(char[]&nbsp;prefix,
             char[]&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers true if the given name starts with the given prefix, false otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#prefixEquals(char[], char[], boolean)">prefixEquals</A></B>(char[]&nbsp;prefix,
             char[]&nbsp;name,
             boolean&nbsp;isCaseSensitive)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers true if the given name starts with the given prefix, false otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#replace(char[], char[], char[])">replace</A></B>(char[]&nbsp;array,
        char[]&nbsp;toBeReplaced,
        char[]&nbsp;replacementChars)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers a new array of characters with substitutions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#replace(char[], char, char)">replace</A></B>(char[]&nbsp;array,
        char&nbsp;toBeReplaced,
        char&nbsp;replacementChar)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replace all occurrence of the character to be replaced with the remplacement character in the
 given array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#splitAndTrimOn(char, char[])">splitAndTrimOn</A></B>(char&nbsp;divider,
               char[]&nbsp;array)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a new array which is the split of the given array using the given divider and triming each subarray to remove
 whitespaces equals to ' '.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#splitOn(char, char[])">splitOn</A></B>(char&nbsp;divider,
        char[]&nbsp;array)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a new array which is the split of the given array using the given divider.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#splitOn(char, char[], int, int)">splitOn</A></B>(char&nbsp;divider,
        char[]&nbsp;array,
        int&nbsp;start,
        int&nbsp;end)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a new array which is the split of the given array using the given divider.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#startsWith(char[], char[])">startsWith</A></B>(char[]&nbsp;array,
           char[]&nbsp;toBeFound)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers true if the given array starts with the given characters, false otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char[][]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#subarray(char[][], int, int)">subarray</A></B>(char[][]&nbsp;array,
         int&nbsp;start,
         int&nbsp;end)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers a new array which is a copy of the given array starting at the given start and 
 ending at the given end.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#subarray(char[], int, int)">subarray</A></B>(char[]&nbsp;array,
         int&nbsp;start,
         int&nbsp;end)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers a new array which is a copy of the given array starting at the given start and 
 ending at the given end.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#toLowerCase(char[])">toLowerCase</A></B>(char[]&nbsp;chars)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers the result of a char[] conversion to lowercase.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#toString(char[][])">toString</A></B>(char[][]&nbsp;array)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers a string which is the concatenation of the given array using the '.' as a separator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/rohanclan/cfml/parser/CharOperation.html#trim(char[])">trim</A></B>(char[]&nbsp;chars)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Answers a new array removing leading and trailing spaces (' ').</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="NO_CHAR"><!-- --></A><H3>
NO_CHAR</H3>
<PRE>
public static final char[] <B>NO_CHAR</B></PRE>
<DL>
<DD>Constant for an empty char array
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="NO_CHAR_CHAR"><!-- --></A><H3>
NO_CHAR_CHAR</H3>
<PRE>
public static final char[][] <B>NO_CHAR_CHAR</B></PRE>
<DL>
<DD>Constant for an empty char array with two dimensions.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="CharOperation()"><!-- --></A><H3>
CharOperation</H3>
<PRE>
public <B>CharOperation</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="append(char[], char)"><!-- --></A><H3>
append</H3>
<PRE>
public static final char[] <B>append</B>(char[]&nbsp;array,
                                  char&nbsp;suffix)</PRE>
<DL>
<DD>Answers a new array with appending the suffix character at the end of the array.
 <br>
 <br>
 For example:<br>
 <ol>
 <li><pre>
    array = { 'a', 'b' }
    suffix = 'c'
    => result = { 'a', 'b' , 'c' }
 </pre>
 </li>
 <li><pre>
    array = null
    suffix = 'c'
    => result = { 'c' }
 </pre></li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - the array that is concanated with the suffix character<DD><CODE>suffix</CODE> - the suffix character
<DT><B>Returns:</B><DD>the new array</DL>
</DD>
</DL>
<HR>

<A NAME="append(char[], int, char[], int, int)"><!-- --></A><H3>
append</H3>
<PRE>
public static final char[] <B>append</B>(char[]&nbsp;target,
                                  int&nbsp;index,
                                  char[]&nbsp;array,
                                  int&nbsp;start,
                                  int&nbsp;end)</PRE>
<DL>
<DD>Append the given subarray to append to the target array starting at the given index in the target array.
 The start of the subarray is inclusive, the end is exclusive.
 Answers a new target array if it needs to grow, otherwise answers the same target array.
 <br>
 For example:<br>
 <ol>
 <li><pre>
    target = { 'a', 'b', -1 }
    index = 0
    array = { 'c', 'd' }
    start = 0
    end = 1
    => result = { 'a', 'b' , 'c' }
 </pre>
 </li>
 <li><pre>
    target = { 'a', 'b' }
    index = 0
    array = { 'c', 'd' }
    start = 0
    end = 1
    => result = new { 'a', 'b' , 'c', -1 }
 </pre></li>
 <li><pre>
    target = { 'a', 'b', 'c' }
    index = 1
    array = { 'c', 'd', 'e', 'f' }
    start = 1
    end = 4
    => result = new { 'a', 'd' , 'e', 'f', -1, -1 }
 </pre></li>
 </ol>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="arrayConcat(char[][], char[][])"><!-- --></A><H3>
arrayConcat</H3>
<PRE>
public static final char[][] <B>arrayConcat</B>(char[][]&nbsp;first,
                                         char[][]&nbsp;second)</PRE>
<DL>
<DD>Answers the concatenation of the two arrays. It answers null if the two arrays are null.
 If the first array is null, then the second array is returned.
 If the second array is null, then the first array is returned.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    first = null
    second = null
    => result = null
 </pre>
 </li>
 <li><pre>
    first = { { ' a' } }
    second = null
    => result = { { ' a' } }
 </pre>
 </li>
 <li><pre>
    first = null
    second = { { ' a' } }
    => result = { { ' a' } }
 </pre>
 </li>
 <li><pre>
    first = { { ' b' } }
    second = { { ' a' } }
    => result = { { ' b' }, { ' a' } }
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>first</CODE> - the first array to concatenate<DD><CODE>second</CODE> - the second array to concatenate
<DT><B>Returns:</B><DD>the concatenation of the two arrays, or null if the two arrays are null.</DL>
</DD>
</DL>
<HR>

<A NAME="arrayConcat(char[][], char[])"><!-- --></A><H3>
arrayConcat</H3>
<PRE>
public static final char[][] <B>arrayConcat</B>(char[][]&nbsp;first,
                                         char[]&nbsp;second)</PRE>
<DL>
<DD>Answers a new array adding the second array at the end of first array.
 It answers null if the first and second are null.
 If the first array is null, then a new array char[][] is created with second.
 If the second array is null, then the first array is returned.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    first = null
    second = { 'a' }
    => result = { { ' a' } }
 </pre>
 <li><pre>
    first = { { ' a' } }
    second = null
    => result = { { ' a' } }
 </pre>
 </li>
 <li><pre>
    first = { { ' a' } }
    second = { ' b' }
    => result = { { ' a' } , { ' b' } }
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>first</CODE> - the first array to concatenate<DD><CODE>second</CODE> - the array to add at the end of the first array
<DT><B>Returns:</B><DD>a new array adding the second array at the end of first array, or null if the two arrays are null.</DL>
</DD>
</DL>
<HR>

<A NAME="concat(char[], char[])"><!-- --></A><H3>
concat</H3>
<PRE>
public static final char[] <B>concat</B>(char[]&nbsp;first,
                                  char[]&nbsp;second)</PRE>
<DL>
<DD>Answers the concatenation of the two arrays. It answers null if the two arrays are null.
 If the first array is null, then the second array is returned.
 If the second array is null, then the first array is returned.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    first = null
    second = { 'a' }
    => result = { ' a' }
 </pre>
 </li>
 <li><pre>
    first = { ' a' }
    second = null
    => result = { ' a' }
 </pre>
 </li>
 <li><pre>
    first = { ' a' }
    second = { ' b' }
    => result = { ' a' , ' b' }
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>first</CODE> - the first array to concatenate<DD><CODE>second</CODE> - the second array to concatenate
<DT><B>Returns:</B><DD>the concatenation of the two arrays, or null if the two arrays are null.</DL>
</DD>
</DL>
<HR>

<A NAME="concat(char[], char[], char[])"><!-- --></A><H3>
concat</H3>
<PRE>
public static final char[] <B>concat</B>(char[]&nbsp;first,
                                  char[]&nbsp;second,
                                  char[]&nbsp;third)</PRE>
<DL>
<DD>Answers the concatenation of the three arrays. It answers null if the three arrays are null.
 If first is null, it answers the concatenation of second and third.
 If second is null, it answers the concatenation of first and third.
 If third is null, it answers the concatenation of first and second.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    first = null
    second = { 'a' }
    third = { 'b' }
    => result = { ' a', 'b' }
 </pre>
 </li>
 <li><pre>
    first = { 'a' }
    second = null
    third = { 'b' }
    => result = { ' a', 'b' }
 </pre>
 </li>
 <li><pre>
    first = { 'a' }
    second = { 'b' }
    third = null
    => result = { ' a', 'b' }
 </pre>
 </li>
 <li><pre>
    first = null
    second = null
    third = null
    => result = null
 </pre>
 </li>
 <li><pre>
    first = { 'a' }
    second = { 'b' }
    third = { 'c' }
    => result = { 'a', 'b', 'c' }
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>first</CODE> - the first array to concatenate<DD><CODE>second</CODE> - the second array to concatenate<DD><CODE>third</CODE> - the third array to concatenate
<DT><B>Returns:</B><DD>the concatenation of the three arrays, or null if the three arrays are null.</DL>
</DD>
</DL>
<HR>

<A NAME="concat(char[], char[], char)"><!-- --></A><H3>
concat</H3>
<PRE>
public static final char[] <B>concat</B>(char[]&nbsp;first,
                                  char[]&nbsp;second,
                                  char&nbsp;separator)</PRE>
<DL>
<DD>Answers the concatenation of the two arrays inserting the separator character between the two arrays.
 It answers null if the two arrays are null.
 If the first array is null, then the second array is returned.
 If the second array is null, then the first array is returned.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    first = null
    second = { 'a' }
    separator = '/'
    => result = { ' a' }
 </pre>
 </li>
 <li><pre>
    first = { ' a' }
    second = null
    separator = '/'
    => result = { ' a' }
 </pre>
 </li>
 <li><pre>
    first = { ' a' }
    second = { ' b' }
    separator = '/'
    => result = { ' a' , '/', 'b' }
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>first</CODE> - the first array to concatenate<DD><CODE>second</CODE> - the second array to concatenate<DD><CODE>separator</CODE> - the character to insert
<DT><B>Returns:</B><DD>the concatenation of the two arrays inserting the separator character 
 between the two arrays , or null if the two arrays are null.</DL>
</DD>
</DL>
<HR>

<A NAME="concat(char[], char, char[], char, char[])"><!-- --></A><H3>
concat</H3>
<PRE>
public static final char[] <B>concat</B>(char[]&nbsp;first,
                                  char&nbsp;sep1,
                                  char[]&nbsp;second,
                                  char&nbsp;sep2,
                                  char[]&nbsp;third)</PRE>
<DL>
<DD>Answers the concatenation of the three arrays inserting the sep1 character between the 
 two arrays and sep2 between the last two.
 It answers null if the three arrays are null.
 If the first array is null, then it answers the concatenation of second and third inserting
 the sep2 character between them.
 If the second array is null, then the first array is returned.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    first = null
    second = { 'a' }
    separator = '/'
    => result = { ' a' }
 </pre>
 </li>
 <li><pre>
    first = { ' a' }
    second = null
    separator = '/'
    => result = { ' a' }
 </pre>
 </li>
 <li><pre>
    first = { ' a' }
    second = { ' b' }
    separator = '/'
    => result = { ' a' , '/', 'b' }
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>first</CODE> - the first array to concatenate<DD><CODE>second</CODE> - the second array to concatenate
<DT><B>Returns:</B><DD>the concatenation of the two arrays inserting the separator character 
 between the two arrays , or null if the two arrays are null.</DL>
</DD>
</DL>
<HR>

<A NAME="concat(char, char[], char)"><!-- --></A><H3>
concat</H3>
<PRE>
public static final char[] <B>concat</B>(char&nbsp;prefix,
                                  char[]&nbsp;array,
                                  char&nbsp;suffix)</PRE>
<DL>
<DD>Answers a new array with prepending the prefix character and appending the suffix 
 character at the end of the array. If array is null, it answers a new array containing the 
 prefix and the suffix characters.
 <br>
 <br>
 For example:<br>
 <ol>
 <li><pre>
    prefix = 'a'
    array = { 'b' }
    suffix = 'c'
    => result = { 'a', 'b' , 'c' }
 </pre>
 </li>
 <li><pre>
    prefix = 'a'
    array = null
    suffix = 'c'
    => result = { 'a', 'c' }
 </pre></li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>prefix</CODE> - the prefix character<DD><CODE>array</CODE> - the array that is concanated with the prefix and suffix characters<DD><CODE>suffix</CODE> - the suffix character
<DT><B>Returns:</B><DD>the new array</DL>
</DD>
</DL>
<HR>

<A NAME="concatWith(char[], char[][], char)"><!-- --></A><H3>
concatWith</H3>
<PRE>
public static final char[] <B>concatWith</B>(char[]&nbsp;name,
                                      char[][]&nbsp;array,
                                      char&nbsp;separator)</PRE>
<DL>
<DD>Answers the concatenation of the given array parts using the given separator between each
 part and appending the given name at the end.
 <br>
 <br>
 For example:<br>
 <ol>
 <li><pre>
    name = { 'c' }
    array = { { 'a' }, { 'b' } }
    separator = '.'
    => result = { 'a', '.', 'b' , '.', 'c' }
 </pre>
 </li>
 <li><pre>
    name = null
    array = { { 'a' }, { 'b' } }
    separator = '.'
    => result = { 'a', '.', 'b' }
 </pre></li>
 <li><pre>
    name = { ' c' }
    array = null
    separator = '.'
    => result = { 'c' }
 </pre></li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>name</CODE> - the given name<DD><CODE>array</CODE> - the given array<DD><CODE>separator</CODE> - the given separator
<DT><B>Returns:</B><DD>the concatenation of the given array parts using the given separator between each
 part and appending the given name at the end</DL>
</DD>
</DL>
<HR>

<A NAME="concatWith(char[][], char[], char)"><!-- --></A><H3>
concatWith</H3>
<PRE>
public static final char[] <B>concatWith</B>(char[][]&nbsp;array,
                                      char[]&nbsp;name,
                                      char&nbsp;separator)</PRE>
<DL>
<DD>Answers the concatenation of the given array parts using the given separator between each
 part and appending the given name at the end.
 <br>
 <br>
 For example:<br>
 <ol>
 <li><pre>
    name = { 'c' }
    array = { { 'a' }, { 'b' } }
    separator = '.'
    => result = { 'a', '.', 'b' , '.', 'c' }
 </pre>
 </li>
 <li><pre>
    name = null
    array = { { 'a' }, { 'b' } }
    separator = '.'
    => result = { 'a', '.', 'b' }
 </pre></li>
 <li><pre>
    name = { ' c' }
    array = null
    separator = '.'
    => result = { 'c' }
 </pre></li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - the given array<DD><CODE>name</CODE> - the given name<DD><CODE>separator</CODE> - the given separator
<DT><B>Returns:</B><DD>the concatenation of the given array parts using the given separator between each
 part and appending the given name at the end</DL>
</DD>
</DL>
<HR>

<A NAME="concatWith(char[][], char)"><!-- --></A><H3>
concatWith</H3>
<PRE>
public static final char[] <B>concatWith</B>(char[][]&nbsp;array,
                                      char&nbsp;separator)</PRE>
<DL>
<DD>Answers the concatenation of the given array parts using the given separator between each part.
 <br>
 <br>
 For example:<br>
 <ol>
 <li><pre>
    array = { { 'a' }, { 'b' } }
    separator = '.'
    => result = { 'a', '.', 'b' }
 </pre>
 </li>
 <li><pre>
    array = null
    separator = '.'
    => result = { }
 </pre></li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - the given array<DD><CODE>separator</CODE> - the given separator
<DT><B>Returns:</B><DD>the concatenation of the given array parts using the given separator between each part</DL>
</DD>
</DL>
<HR>

<A NAME="contains(char, char[][])"><!-- --></A><H3>
contains</H3>
<PRE>
public static final boolean <B>contains</B>(char&nbsp;character,
                                     char[][]&nbsp;array)</PRE>
<DL>
<DD>Answers true if the array contains an occurrence of character, false otherwise.
 
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    character = 'c'
    array = { { ' a' }, { ' b' } }
    result => false
 </pre>
 </li>
 <li><pre>
    character = 'a'
    array = { { ' a' }, { ' b' } }
    result => true
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>character</CODE> - the character to search<DD><CODE>array</CODE> - the array in which the search is done
<DT><B>Returns:</B><DD>true if the array contains an occurrence of character, false otherwise.
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if array is null.</DL>
</DD>
</DL>
<HR>

<A NAME="contains(char, char[])"><!-- --></A><H3>
contains</H3>
<PRE>
public static final boolean <B>contains</B>(char&nbsp;character,
                                     char[]&nbsp;array)</PRE>
<DL>
<DD>Answers true if the array contains an occurrence of character, false otherwise.
 
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    character = 'c'
    array = { ' b'  }
    result => false
 </pre>
 </li>
 <li><pre>
    character = 'a'
    array = { ' a' , ' b' }
    result => true
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>character</CODE> - the character to search<DD><CODE>array</CODE> - the array in which the search is done
<DT><B>Returns:</B><DD>true if the array contains an occurrence of character, false otherwise.
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if array is null.</DL>
</DD>
</DL>
<HR>

<A NAME="deepCopy(char[][])"><!-- --></A><H3>
deepCopy</H3>
<PRE>
public static final char[][] <B>deepCopy</B>(char[][]&nbsp;toCopy)</PRE>
<DL>
<DD>Answers a deep copy of the toCopy array.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>toCopy</CODE> - the array to copy
<DT><B>Returns:</B><DD>a deep copy of the toCopy array.</DL>
</DD>
</DL>
<HR>

<A NAME="endsWith(char[], char[])"><!-- --></A><H3>
endsWith</H3>
<PRE>
public static final boolean <B>endsWith</B>(char[]&nbsp;array,
                                     char[]&nbsp;toBeFound)</PRE>
<DL>
<DD>Return true if array ends with the sequence of characters contained in toBeFound, 
 otherwise false.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    array = { 'a', 'b', 'c', 'd' }
    toBeFound = { 'b', 'c' }
    result => false
 </pre>
 </li>
 <li><pre>
    array = { 'a', 'b', 'c' }
    toBeFound = { 'b', 'c' }
    result => true
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - the array to check<DD><CODE>toBeFound</CODE> - the array to find
<DT><B>Returns:</B><DD>true if array ends with the sequence of characters contained in toBeFound, 
 otherwise false.
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if array is null or toBeFound is null</DL>
</DD>
</DL>
<HR>

<A NAME="equals(char[][], char[][])"><!-- --></A><H3>
equals</H3>
<PRE>
public static final boolean <B>equals</B>(char[][]&nbsp;first,
                                   char[][]&nbsp;second)</PRE>
<DL>
<DD>Answers true if the two arrays are identical character by character, otherwise false.
 The equality is case sensitive.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    first = null
    second = null
    result => true
 </pre>
 </li>
 <li><pre>
    first = { { } }
    second = null
    result => false
 </pre>
 </li>
 <li><pre>
    first = { { 'a' } }
    second = { { 'a' } }
    result => true
 </pre>
 </li>
 <li><pre>
    first = { { 'A' } }
    second = { { 'a' } }
    result => false
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>first</CODE> - the first array<DD><CODE>second</CODE> - the second array
<DT><B>Returns:</B><DD>true if the two arrays are identical character by character, otherwise false</DL>
</DD>
</DL>
<HR>

<A NAME="equals(char[][], char[][], boolean)"><!-- --></A><H3>
equals</H3>
<PRE>
public static final boolean <B>equals</B>(char[][]&nbsp;first,
                                   char[][]&nbsp;second,
                                   boolean&nbsp;isCaseSensitive)</PRE>
<DL>
<DD>If isCaseSensite is true, answers true if the two arrays are identical character
 by character, otherwise false.
 If it is false, answers true if the two arrays are identical character by 
 character without checking the case, otherwise false.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    first = null
    second = null
    isCaseSensitive = true
    result => true
 </pre>
 </li>
 <li><pre>
    first = { { } }
    second = null
    isCaseSensitive = true
    result => false
 </pre>
 </li>
 <li><pre>
    first = { { 'A' } }
    second = { { 'a' } }
    isCaseSensitive = true
    result => false
 </pre>
 </li>
 <li><pre>
    first = { { 'A' } }
    second = { { 'a' } }
    isCaseSensitive = false
    result => true
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>first</CODE> - the first array<DD><CODE>second</CODE> - the second array<DD><CODE>isCaseSensitive</CODE> - check whether or not the equality should be case sensitive
<DT><B>Returns:</B><DD>true if the two arrays are identical character by character according to the value
 of isCaseSensitive, otherwise false</DL>
</DD>
</DL>
<HR>

<A NAME="equals(char[], char[])"><!-- --></A><H3>
equals</H3>
<PRE>
public static final boolean <B>equals</B>(char[]&nbsp;first,
                                   char[]&nbsp;second)</PRE>
<DL>
<DD>Answers true if the two arrays are identical character by character, otherwise false.
 The equality is case sensitive.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    first = null
    second = null
    result => true
 </pre>
 </li>
 <li><pre>
    first = { }
    second = null
    result => false
 </pre>
 </li>
 <li><pre>
    first = { 'a' }
    second = { 'a' }
    result => true
 </pre>
 </li>
 <li><pre>
    first = { 'a' }
    second = { 'A' }
    result => false
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>first</CODE> - the first array<DD><CODE>second</CODE> - the second array
<DT><B>Returns:</B><DD>true if the two arrays are identical character by character, otherwise false</DL>
</DD>
</DL>
<HR>

<A NAME="equals(char[], char[], boolean)"><!-- --></A><H3>
equals</H3>
<PRE>
public static final boolean <B>equals</B>(char[]&nbsp;first,
                                   char[]&nbsp;second,
                                   boolean&nbsp;isCaseSensitive)</PRE>
<DL>
<DD>If isCaseSensite is true, answers true if the two arrays are identical character
 by character, otherwise false.
 If it is false, answers true if the two arrays are identical character by 
 character without checking the case, otherwise false.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    first = null
    second = null
    isCaseSensitive = true
    result => true
 </pre>
 </li>
 <li><pre>
    first = { }
    second = null
    isCaseSensitive = true
    result => false
 </pre>
 </li>
 <li><pre>
    first = { 'A' }
    second = { 'a' }
    isCaseSensitive = true
    result => false
 </pre>
 </li>
 <li><pre>
    first = { 'A' }
    second = { 'a' }
    isCaseSensitive = false
    result => true
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>first</CODE> - the first array<DD><CODE>second</CODE> - the second array<DD><CODE>isCaseSensitive</CODE> - check whether or not the equality should be case sensitive
<DT><B>Returns:</B><DD>true if the two arrays are identical character by character according to the value
 of isCaseSensitive, otherwise false</DL>
</DD>
</DL>
<HR>

<A NAME="fragmentEquals(char[], char[], int, boolean)"><!-- --></A><H3>
fragmentEquals</H3>
<PRE>
public static final boolean <B>fragmentEquals</B>(char[]&nbsp;fragment,
                                           char[]&nbsp;name,
                                           int&nbsp;startIndex,
                                           boolean&nbsp;isCaseSensitive)</PRE>
<DL>
<DD>If isCaseSensite is true, the equality is case sensitive, otherwise it is case insensitive.
 
 Answers true if the name contains the fragment at the starting index startIndex, otherwise false.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    fragment = { 'b', 'c' , 'd' }
    name = { 'a', 'b', 'c' , 'd' }
    startIndex = 1
    isCaseSensitive = true
    result => true
 </pre>
 </li>
 <li><pre>
    fragment = { 'b', 'c' , 'd' }
    name = { 'a', 'b', 'C' , 'd' }
    startIndex = 1
    isCaseSensitive = true
    result => false
 </pre>
 </li>
 <li><pre>
    fragment = { 'b', 'c' , 'd' }
    name = { 'a', 'b', 'C' , 'd' }
    startIndex = 0
    isCaseSensitive = false
    result => false
 </pre>
 </li>
 <li><pre>
    fragment = { 'b', 'c' , 'd' }
    name = { 'a', 'b'}
    startIndex = 0
    isCaseSensitive = true
    result => false
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fragment</CODE> - the fragment to check<DD><CODE>startIndex</CODE> - the starting index<DD><CODE>isCaseSensitive</CODE> - check whether or not the equality should be case sensitive
<DT><B>Returns:</B><DD>true if the name contains the fragment at the starting index startIndex according to the 
 value of isCaseSensitive, otherwise false.
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if fragment or name is null.</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(char[])"><!-- --></A><H3>
hashCode</H3>
<PRE>
public static final int <B>hashCode</B>(char[]&nbsp;array)</PRE>
<DL>
<DD>Answers a hashcode for the array
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - the array for which a hashcode is required
<DT><B>Returns:</B><DD>the hashcode
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if array is null</DL>
</DD>
</DL>
<HR>

<A NAME="isWhitespace(char)"><!-- --></A><H3>
isWhitespace</H3>
<PRE>
public static boolean <B>isWhitespace</B>(char&nbsp;c)</PRE>
<DL>
<DD>Answers true if c is a whitespace according to the JLS (&#92;u000a, &#92;u000c, &#92;u000d, &#92;u0009), otherwise false.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    c = ' '
    result => true
 </pre>
 </li>
 <li><pre>
    c = '&#92;u3000'
    result => false
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c</CODE> - the character to check
<DT><B>Returns:</B><DD>true if c is a whitespace according to the JLS, otherwise false.</DL>
</DD>
</DL>
<HR>

<A NAME="indexOf(char, char[])"><!-- --></A><H3>
indexOf</H3>
<PRE>
public static final int <B>indexOf</B>(char&nbsp;toBeFound,
                                char[]&nbsp;array)</PRE>
<DL>
<DD>Answers the first index in the array for which the corresponding character is
 equal to toBeFound. Answers -1 if no occurrence of this character is found.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    toBeFound = 'c'
    array = { ' a', 'b', 'c', 'd' }
    result => 2
 </pre>
 </li>
 <li><pre>
    toBeFound = 'e'
    array = { ' a', 'b', 'c', 'd' }
    result => -1
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>toBeFound</CODE> - the character to search<DD><CODE>array</CODE> - the array to be searched
<DT><B>Returns:</B><DD>the first index in the array for which the corresponding character is
 equal to toBeFound, -1 otherwise
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if array is null</DL>
</DD>
</DL>
<HR>

<A NAME="indexOf(char, char[], int)"><!-- --></A><H3>
indexOf</H3>
<PRE>
public static final int <B>indexOf</B>(char&nbsp;toBeFound,
                                char[]&nbsp;array,
                                int&nbsp;start)</PRE>
<DL>
<DD>Answers the first index in the array for which the corresponding character is
 equal to toBeFound starting the search at index start.
 Answers -1 if no occurrence of this character is found.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    toBeFound = 'c'
    array = { ' a', 'b', 'c', 'd' }
    start = 2
    result => 2
 </pre>
 </li>
 <li><pre>
    toBeFound = 'c'
    array = { ' a', 'b', 'c', 'd' }
    start = 3
    result => -1
 </pre>
 </li>
 <li><pre>
    toBeFound = 'e'
    array = { ' a', 'b', 'c', 'd' }
    start = 1
    result => -1
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>toBeFound</CODE> - the character to search<DD><CODE>array</CODE> - the array to be searched<DD><CODE>start</CODE> - the starting index
<DT><B>Returns:</B><DD>the first index in the array for which the corresponding character is
 equal to toBeFound, -1 otherwise
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if array is null
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if  start is lower than 0</DL>
</DD>
</DL>
<HR>

<A NAME="lastIndexOf(char, char[])"><!-- --></A><H3>
lastIndexOf</H3>
<PRE>
public static final int <B>lastIndexOf</B>(char&nbsp;toBeFound,
                                    char[]&nbsp;array)</PRE>
<DL>
<DD>Answers the last index in the array for which the corresponding character is
 equal to toBeFound starting from the end of the array.
 Answers -1 if no occurrence of this character is found.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    toBeFound = 'c'
    array = { ' a', 'b', 'c', 'd' , 'c', 'e' }
    result => 4
 </pre>
 </li>
 <li><pre>
    toBeFound = 'e'
    array = { ' a', 'b', 'c', 'd' }
    result => -1
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>toBeFound</CODE> - the character to search<DD><CODE>array</CODE> - the array to be searched
<DT><B>Returns:</B><DD>the last index in the array for which the corresponding character is
 equal to toBeFound starting from the end of the array, -1 otherwise
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if array is null</DL>
</DD>
</DL>
<HR>

<A NAME="lastIndexOf(char, char[], int)"><!-- --></A><H3>
lastIndexOf</H3>
<PRE>
public static final int <B>lastIndexOf</B>(char&nbsp;toBeFound,
                                    char[]&nbsp;array,
                                    int&nbsp;startIndex)</PRE>
<DL>
<DD>Answers the last index in the array for which the corresponding character is
 equal to toBeFound stopping at the index startIndex.
 Answers -1 if no occurrence of this character is found.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    toBeFound = 'c'
    array = { ' a', 'b', 'c', 'd' }
    startIndex = 2
    result => 2
 </pre>
 </li>
 <li><pre>
    toBeFound = 'c'
    array = { ' a', 'b', 'c', 'd', 'e' }
    startIndex = 3
    result => -1
 </pre>
 </li>
 <li><pre>
    toBeFound = 'e'
    array = { ' a', 'b', 'c', 'd' }
    startIndex = 0
    result => -1
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>toBeFound</CODE> - the character to search<DD><CODE>array</CODE> - the array to be searched<DD><CODE>startIndex</CODE> - the stopping index
<DT><B>Returns:</B><DD>the last index in the array for which the corresponding character is
 equal to toBeFound stopping at the index startIndex, -1 otherwise
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if array is null
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if startIndex is lower than 0</DL>
</DD>
</DL>
<HR>

<A NAME="lastIndexOf(char, char[], int, int)"><!-- --></A><H3>
lastIndexOf</H3>
<PRE>
public static final int <B>lastIndexOf</B>(char&nbsp;toBeFound,
                                    char[]&nbsp;array,
                                    int&nbsp;startIndex,
                                    int&nbsp;endIndex)</PRE>
<DL>
<DD>Answers the last index in the array for which the corresponding character is
 equal to toBeFound starting from endIndex to startIndex.
 Answers -1 if no occurrence of this character is found.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    toBeFound = 'c'
    array = { ' a', 'b', 'c', 'd' }
    startIndex = 2
    endIndex = 2
    result => 2
 </pre>
 </li>
 <li><pre>
    toBeFound = 'c'
    array = { ' a', 'b', 'c', 'd', 'e' }
    startIndex = 3
    endIndex = 4
    result => -1
 </pre>
 </li>
 <li><pre>
    toBeFound = 'e'
    array = { ' a', 'b', 'c', 'd' }
    startIndex = 0
    endIndex = 3
    result => -1
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>toBeFound</CODE> - the character to search<DD><CODE>array</CODE> - the array to be searched<DD><CODE>startIndex</CODE> - the stopping index<DD><CODE>endIndex</CODE> - the starting index
<DT><B>Returns:</B><DD>the last index in the array for which the corresponding character is
 equal to toBeFound starting from endIndex to startIndex, -1 otherwise
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if array is null
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if endIndex is greater or equals to array length or starting is lower than 0</DL>
</DD>
</DL>
<HR>

<A NAME="lastSegment(char[], char)"><!-- --></A><H3>
lastSegment</H3>
<PRE>
public static final char[] <B>lastSegment</B>(char[]&nbsp;array,
                                       char&nbsp;separator)</PRE>
<DL>
<DD>Answers the last portion of a name given a separator.
 <br>
 <br>
 For example,
 <pre>
 	lastSegment("java.lang.Object".toCharArray(),'.') --> Object
 </pre>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - the array<DD><CODE>separator</CODE> - the given separator
<DT><B>Returns:</B><DD>the last portion of a name given a separator
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if array is null</DL>
</DD>
</DL>
<HR>

<A NAME="match(char[], char[], boolean)"><!-- --></A><H3>
match</H3>
<PRE>
public static final boolean <B>match</B>(char[]&nbsp;pattern,
                                  char[]&nbsp;name,
                                  boolean&nbsp;isCaseSensitive)</PRE>
<DL>
<DD>Answers true if the pattern matches the given name, false otherwise. This char[] pattern matching
 accepts wild-cards '*' and '?'.

 When not case sensitive, the pattern is assumed to already be lowercased, the
 name will be lowercased character per character as comparing.
 If name is null, the answer is false.
 If pattern is null, the answer is true if name is not null.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    pattern = { '?', 'b', '*' }
    name = { 'a', 'b', 'c' , 'd' }
    isCaseSensitive = true
    result => true
 </pre>
 </li>
 <li><pre>
    pattern = { '?', 'b', '?' }
    name = { 'a', 'b', 'c' , 'd' }
    isCaseSensitive = true
    result => false
 </pre>
 </li>
 <li><pre>
    pattern = { 'b', '*' }
    name = { 'a', 'b', 'c' , 'd' }
    isCaseSensitive = true
    result => false
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pattern</CODE> - the given pattern<DD><CODE>name</CODE> - the given name<DD><CODE>isCaseSensitive</CODE> - flag to know whether or not the matching should be case sensitive
<DT><B>Returns:</B><DD>true if the pattern matches the given name, false otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="match(char[], int, int, char[], int, int, boolean)"><!-- --></A><H3>
match</H3>
<PRE>
public static final boolean <B>match</B>(char[]&nbsp;pattern,
                                  int&nbsp;patternStart,
                                  int&nbsp;patternEnd,
                                  char[]&nbsp;name,
                                  int&nbsp;nameStart,
                                  int&nbsp;nameEnd,
                                  boolean&nbsp;isCaseSensitive)</PRE>
<DL>
<DD>Answers true if the a sub-pattern matches the subpart of the given name, false otherwise.
 char[] pattern matching, accepting wild-cards '*' and '?'. Can match only subset of name/pattern.
 end positions are non-inclusive.
 The subpattern is defined by the patternStart and pattternEnd positions.
 When not case sensitive, the pattern is assumed to already be lowercased, the
 name will be lowercased character per character as comparing.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    pattern = { '?', 'b', '*' }
    patternStart = 1
    patternEnd = 3
    name = { 'a', 'b', 'c' , 'd' }
    nameStart = 1
    nameEnd = 4
    isCaseSensitive = true
    result => true
 </pre>
 </li>
 <li><pre>
    pattern = { '?', 'b', '*' }
    patternStart = 1
    patternEnd = 2
    name = { 'a', 'b', 'c' , 'd' }
    nameStart = 1
    nameEnd = 2
    isCaseSensitive = true
    result => false
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pattern</CODE> - the given pattern<DD><CODE>patternStart</CODE> - the given pattern start<DD><CODE>patternEnd</CODE> - the given pattern end<DD><CODE>name</CODE> - the given name<DD><CODE>nameStart</CODE> - the given name start<DD><CODE>nameEnd</CODE> - the given name end<DD><CODE>isCaseSensitive</CODE> - flag to know if the matching should be case sensitive
<DT><B>Returns:</B><DD>true if the a sub-pattern matches the subpart of the given name, false otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="pathMatch(char[], char[], boolean, char)"><!-- --></A><H3>
pathMatch</H3>
<PRE>
public static final boolean <B>pathMatch</B>(char[]&nbsp;pattern,
                                      char[]&nbsp;filepath,
                                      boolean&nbsp;isCaseSensitive,
                                      char&nbsp;pathSeparator)</PRE>
<DL>
<DD>Answers true if the pattern matches the filepath using the pathSepatator, false otherwise.
 
 Path char[] pattern matching, accepting wild-cards '**', '*' and '?' (using Ant directory tasks
 conventions, also see "http://jakarta.apache.org/ant/manual/dirtasks.html#defaultexcludes").
 Path pattern matching is enhancing regular pattern matching in supporting extra rule where '**' represent
 any folder combination.
 Special rules: 
 - foo\  is equivalent to foo\**   
 - *.php is equivalent to **\*.php
 When not case sensitive, the pattern is assumed to already be lowercased, the
 name will be lowercased character per character as comparing.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pattern</CODE> - the given pattern<DD><CODE>filepath</CODE> - the given path<DD><CODE>isCaseSensitive</CODE> - to find out whether or not the matching should be case sensitive<DD><CODE>pathSeparator</CODE> - the given path separator
<DT><B>Returns:</B><DD>true if the pattern matches the filepath using the pathSepatator, false otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="occurencesOf(char, char[])"><!-- --></A><H3>
occurencesOf</H3>
<PRE>
public static final int <B>occurencesOf</B>(char&nbsp;toBeFound,
                                     char[]&nbsp;array)</PRE>
<DL>
<DD>Answers the number of occurrences of the given character in the given array, 0 if any.
 
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    toBeFound = 'b'
    array = { 'a' , 'b', 'b', 'a', 'b', 'a' }
    result => 3
 </pre>
 </li>
 <li><pre>
    toBeFound = 'c'
    array = { 'a' , 'b', 'b', 'a', 'b', 'a' }
    result => 0
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>toBeFound</CODE> - the given character<DD><CODE>array</CODE> - the given array
<DT><B>Returns:</B><DD>the number of occurrences of the given character in the given array, 0 if any
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if array is null</DL>
</DD>
</DL>
<HR>

<A NAME="occurencesOf(char, char[], int)"><!-- --></A><H3>
occurencesOf</H3>
<PRE>
public static final int <B>occurencesOf</B>(char&nbsp;toBeFound,
                                     char[]&nbsp;array,
                                     int&nbsp;start)</PRE>
<DL>
<DD>Answers the number of occurrences of the given character in the given array starting
 at the given index, 0 if any.
 
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    toBeFound = 'b'
    array = { 'a' , 'b', 'b', 'a', 'b', 'a' }
    start = 2
    result => 2
 </pre>
 </li>
 <li><pre>
    toBeFound = 'c'
    array = { 'a' , 'b', 'b', 'a', 'b', 'a' }
    start = 0
    result => 0
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>toBeFound</CODE> - the given character<DD><CODE>array</CODE> - the given array
<DT><B>Returns:</B><DD>the number of occurrences of the given character in the given array, 0 if any
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if array is null
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if start is lower than 0</DL>
</DD>
</DL>
<HR>

<A NAME="prefixEquals(char[], char[])"><!-- --></A><H3>
prefixEquals</H3>
<PRE>
public static final boolean <B>prefixEquals</B>(char[]&nbsp;prefix,
                                         char[]&nbsp;name)</PRE>
<DL>
<DD>Answers true if the given name starts with the given prefix, false otherwise.
 The comparison is case sensitive.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    prefix = { 'a' , 'b' }
    name = { 'a' , 'b', 'b', 'a', 'b', 'a' }
    result => true
 </pre>
 </li>
 <li><pre>
    prefix = { 'a' , 'c' }
    name = { 'a' , 'b', 'b', 'a', 'b', 'a' }
    result => false
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>prefix</CODE> - the given prefix<DD><CODE>name</CODE> - the given name
<DT><B>Returns:</B><DD>true if the given name starts with the given prefix, false otherwise
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if the given name is null or if the given prefix is null</DL>
</DD>
</DL>
<HR>

<A NAME="prefixEquals(char[], char[], boolean)"><!-- --></A><H3>
prefixEquals</H3>
<PRE>
public static final boolean <B>prefixEquals</B>(char[]&nbsp;prefix,
                                         char[]&nbsp;name,
                                         boolean&nbsp;isCaseSensitive)</PRE>
<DL>
<DD>Answers true if the given name starts with the given prefix, false otherwise.
 isCaseSensitive is used to find out whether or not the comparison should be case sensitive.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    prefix = { 'a' , 'B' }
    name = { 'a' , 'b', 'b', 'a', 'b', 'a' }
    isCaseSensitive = false
    result => true
 </pre>
 </li>
 <li><pre>
    prefix = { 'a' , 'B' }
    name = { 'a' , 'b', 'b', 'a', 'b', 'a' }
    isCaseSensitive = true
    result => false
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>prefix</CODE> - the given prefix<DD><CODE>name</CODE> - the given name<DD><CODE>isCaseSensitive</CODE> - to find out whether or not the comparison should be case sensitive
<DT><B>Returns:</B><DD>true if the given name starts with the given prefix, false otherwise
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if the given name is null or if the given prefix is null</DL>
</DD>
</DL>
<HR>

<A NAME="replace(char[], char, char)"><!-- --></A><H3>
replace</H3>
<PRE>
public static final void <B>replace</B>(char[]&nbsp;array,
                                 char&nbsp;toBeReplaced,
                                 char&nbsp;replacementChar)</PRE>
<DL>
<DD>Replace all occurrence of the character to be replaced with the remplacement character in the
 given array.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    array = { 'a' , 'b', 'b', 'a', 'b', 'a' }
    toBeReplaced = 'b'
    replacementChar = 'a'
    result => No returned value, but array is now equals to { 'a' , 'a', 'a', 'a', 'a', 'a' }
 </pre>
 </li>
 <li><pre>
    array = { 'a' , 'b', 'b', 'a', 'b', 'a' }
    toBeReplaced = 'c'
    replacementChar = 'a'
    result => No returned value, but array is now equals to { 'a' , 'b', 'b', 'a', 'b', 'a' }
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - the given array<DD><CODE>toBeReplaced</CODE> - the character to be replaced<DD><CODE>replacementChar</CODE> - the replacement character
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if the given array is null</DL>
</DD>
</DL>
<HR>

<A NAME="replace(char[], char[], char[])"><!-- --></A><H3>
replace</H3>
<PRE>
public static final char[] <B>replace</B>(char[]&nbsp;array,
                                   char[]&nbsp;toBeReplaced,
                                   char[]&nbsp;replacementChars)</PRE>
<DL>
<DD>Answers a new array of characters with substitutions. No side-effect is operated on the original
 array, in case no substitution happened, then the result is the same as the
 original one.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    array = { 'a' , 'b', 'b', 'a', 'b', 'a' }
    toBeReplaced = { 'b' }
    replacementChar = { 'a', 'a' }
    result => { 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a' }
 </pre>
 </li>
 <li><pre>
    array = { 'a' , 'b', 'b', 'a', 'b', 'a' }
    toBeReplaced = { 'c' }
    replacementChar = { 'a' }
    result => { 'a' , 'b', 'b', 'a', 'b', 'a' }
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>toBeReplaced</CODE> - characters to be replaced
<DT><B>Returns:</B><DD>a new array of characters with substitutions or the given array if none
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if the given array is null</DL>
</DD>
</DL>
<HR>

<A NAME="splitAndTrimOn(char, char[])"><!-- --></A><H3>
splitAndTrimOn</H3>
<PRE>
public static final char[][] <B>splitAndTrimOn</B>(char&nbsp;divider,
                                            char[]&nbsp;array)</PRE>
<DL>
<DD>Return a new array which is the split of the given array using the given divider and triming each subarray to remove
 whitespaces equals to ' '.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    divider = 'b'
    array = { 'a' , 'b', 'b', 'a', 'b', 'a' }
    result => { { 'a' }, {  }, { 'a' }, { 'a' } }
 </pre>
 </li>
 <li><pre>
    divider = 'c'
    array = { 'a' , 'b', 'b', 'a', 'b', 'a' }
    result => { { 'a', 'b', 'b', 'a', 'b', 'a' } }
 </pre>
 </li>
 <li><pre>
    divider = 'b'
    array = { 'a' , ' ', 'b', 'b', 'a', 'b', 'a' }
    result => { { 'a' }, {  }, { 'a' }, { 'a' } }
 </pre>
 </li>
 <li><pre>
    divider = 'c'
    array = { ' ', ' ', 'a' , 'b', 'b', 'a', 'b', 'a', ' ' }
    result => { { 'a', 'b', 'b', 'a', 'b', 'a' } }
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>divider</CODE> - the given divider<DD><CODE>array</CODE> - the given array
<DT><B>Returns:</B><DD>a new array which is the split of the given array using the given divider and triming each subarray to remove
 whitespaces equals to ' '</DL>
</DD>
</DL>
<HR>

<A NAME="splitOn(char, char[])"><!-- --></A><H3>
splitOn</H3>
<PRE>
public static final char[][] <B>splitOn</B>(char&nbsp;divider,
                                     char[]&nbsp;array)</PRE>
<DL>
<DD>Return a new array which is the split of the given array using the given divider.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    divider = 'b'
    array = { 'a' , 'b', 'b', 'a', 'b', 'a' }
    result => { { 'a' }, {  }, { 'a' }, { 'a' } }
 </pre>
 </li>
 <li><pre>
    divider = 'c'
    array = { 'a' , 'b', 'b', 'a', 'b', 'a' }
    result => { { 'a', 'b', 'b', 'a', 'b', 'a' } }
 </pre>
 </li>
 <li><pre>
    divider = 'c'
    array = { ' ', ' ', 'a' , 'b', 'b', 'a', 'b', 'a', ' ' }
    result => { { ' ', 'a', 'b', 'b', 'a', 'b', 'a', ' ' } }
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>divider</CODE> - the given divider<DD><CODE>array</CODE> - the given array
<DT><B>Returns:</B><DD>a new array which is the split of the given array using the given divider</DL>
</DD>
</DL>
<HR>

<A NAME="splitOn(char, char[], int, int)"><!-- --></A><H3>
splitOn</H3>
<PRE>
public static final char[][] <B>splitOn</B>(char&nbsp;divider,
                                     char[]&nbsp;array,
                                     int&nbsp;start,
                                     int&nbsp;end)</PRE>
<DL>
<DD>Return a new array which is the split of the given array using the given divider. The given end 
 is exclusive and the given start is inclusive.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    divider = 'b'
    array = { 'a' , 'b', 'b', 'a', 'b', 'a' }
    start = 2
    end = 5
    result => { {  }, {  }, { 'a' } }
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>divider</CODE> - the given divider<DD><CODE>array</CODE> - the given array<DD><CODE>start</CODE> - the given starting index<DD><CODE>end</CODE> - the given ending index
<DT><B>Returns:</B><DD>a new array which is the split of the given array using the given divider
<DT><B>Throws:</B>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if start is lower than 0 or end is greater than the array length</DL>
</DD>
</DL>
<HR>

<A NAME="startsWith(char[], char[])"><!-- --></A><H3>
startsWith</H3>
<PRE>
public static final boolean <B>startsWith</B>(char[]&nbsp;array,
                                       char[]&nbsp;toBeFound)</PRE>
<DL>
<DD>Answers true if the given array starts with the given characters, false otherwise.
 The comparison is case sensitive.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    toBeFound = { 'a' , 'b' }
    array = { 'a' , 'b', 'b', 'a', 'b', 'a' }
    result => true
 </pre>
 </li>
 <li><pre>
    toBeFound = { 'a' , 'c' }
    array = { 'a' , 'b', 'b', 'a', 'b', 'a' }
    result => false
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - the given array<DD><CODE>toBeFound</CODE> - the given character to search
<DT><B>Returns:</B><DD>true if the given array starts with the given characters, false otherwise
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if the given array is null or if the given characters array to be found is null</DL>
</DD>
</DL>
<HR>

<A NAME="subarray(char[][], int, int)"><!-- --></A><H3>
subarray</H3>
<PRE>
public static final char[][] <B>subarray</B>(char[][]&nbsp;array,
                                      int&nbsp;start,
                                      int&nbsp;end)</PRE>
<DL>
<DD>Answers a new array which is a copy of the given array starting at the given start and 
 ending at the given end. The given start is inclusive and the given end is exclusive.
 Answers null if start is greater than end, if start is lower than 0 or if end is greater 
 than the length of the given array. If end  equals -1, it is converted to the array length.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    array = { { 'a' } , { 'b' } }
    start = 0
    end = 1
    result => { { 'a' } }
 </pre>
 </li>
 <li><pre>
    array = { { 'a' } , { 'b' } }
    start = 0
    end = -1
    result => { { 'a' }, { 'b' } }
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - the given array<DD><CODE>start</CODE> - the given starting index<DD><CODE>end</CODE> - the given ending index
<DT><B>Returns:</B><DD>a new array which is a copy of the given array starting at the given start and 
 ending at the given end
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if the given array is null</DL>
</DD>
</DL>
<HR>

<A NAME="subarray(char[], int, int)"><!-- --></A><H3>
subarray</H3>
<PRE>
public static final char[] <B>subarray</B>(char[]&nbsp;array,
                                    int&nbsp;start,
                                    int&nbsp;end)</PRE>
<DL>
<DD>Answers a new array which is a copy of the given array starting at the given start and 
 ending at the given end. The given start is inclusive and the given end is exclusive.
 Answers null if start is greater than end, if start is lower than 0 or if end is greater 
 than the length of the given array. If end  equals -1, it is converted to the array length.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    array = { 'a' , 'b' }
    start = 0
    end = 1
    result => { 'a' }
 </pre>
 </li>
 <li><pre>
    array = { 'a', 'b' }
    start = 0
    end = -1
    result => { 'a' , 'b' }
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - the given array<DD><CODE>start</CODE> - the given starting index<DD><CODE>end</CODE> - the given ending index
<DT><B>Returns:</B><DD>a new array which is a copy of the given array starting at the given start and 
 ending at the given end
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if the given array is null</DL>
</DD>
</DL>
<HR>

<A NAME="toLowerCase(char[])"><!-- --></A><H3>
toLowerCase</H3>
<PRE>
public static final char[] <B>toLowerCase</B>(char[]&nbsp;chars)</PRE>
<DL>
<DD>Answers the result of a char[] conversion to lowercase. Answers null if the given chars array is null.
 <br>
 NOTE: if no conversion was necessary, then answers back the argument one.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    chars = { 'a' , 'b' }
    result => { 'a' , 'b' }
 </pre>
 </li>
 <li><pre>
    array = { 'A', 'b' }
    result => { 'a' , 'b' }
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>chars</CODE> - the chars to convert
<DT><B>Returns:</B><DD>the result of a char[] conversion to lowercase</DL>
</DD>
</DL>
<HR>

<A NAME="trim(char[])"><!-- --></A><H3>
trim</H3>
<PRE>
public static final char[] <B>trim</B>(char[]&nbsp;chars)</PRE>
<DL>
<DD>Answers a new array removing leading and trailing spaces (' '). Answers the given array if there is no
 space characters to remove.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    chars = { ' ', 'a' , 'b', ' ',  ' ' }
    result => { 'a' , 'b' }
 </pre>
 </li>
 <li><pre>
    array = { 'A', 'b' }
    result => { 'A' , 'b' }
 </pre>
 </li>
 </ol>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>chars</CODE> - the given array
<DT><B>Returns:</B><DD>a new array removing leading and trailing spaces (' ')</DL>
</DD>
</DL>
<HR>

<A NAME="toString(char[][])"><!-- --></A><H3>
toString</H3>
<PRE>
public static final java.lang.String <B>toString</B>(char[][]&nbsp;array)</PRE>
<DL>
<DD>Answers a string which is the concatenation of the given array using the '.' as a separator.
 <br>
 <br>
 For example:
 <ol>
 <li><pre>
    array = { { 'a' } , { 'b' } }
    result => "a.b"
 </pre>
 </li>
 <li><pre>
    array = { { ' ',  'a' } , { 'b' } }
    result => " a.b"
 </pre>
 </li>
 </ol>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a string which is the concatenation of the given array using the '.' as a separator</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/CharOperation.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../com/rohanclan/cfml/parser/CFProblem.html" title="class in com.rohanclan.cfml.parser"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../com/rohanclan/cfml/parser/CommentParser.html" title="class in com.rohanclan.cfml.parser"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="CharOperation.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
